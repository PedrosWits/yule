\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{enumerate}
\usepackage{float}

\renewcommand{\topfraction}{0.9}
\pagestyle{fancy}
\fancyhf{}
\rhead{Alex Kell and Pedro Pinto da Silva}
\lhead{Programming for Big Data Project}
\rfoot{Page \thepage}

% \textwidth=6.0in
% \textheight=8.5in
% \oddsidemargin=.1in
% \evensidemargin=.1in
% \headheight=-.3in
% \setlength\parindent{0pt}

\begin{document}

\title{Modelling Evolutionary Trees \\ CSC8622}
\author{Pedro Pinto da Silva \and Alexander Kell}

\maketitle

%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
\section*{Part 1}

\subsection*{Question (i)}

Below we present our functions for generating a Yule tree. The algorithm for building the structure of the tree is straightforward:
\begin{enumerate}
  \item Initialize a vector of size $2n -2$ with zeros.
  \item For each value $j$ in $1$ to $n - 1$:
  \begin{enumerate} 
        \item Find the non-zero elements of the vector whose index (represent extant species).\\ Special case for $j=1$.
        \item Sample one value from the set of candidates (parent).\\ Special case for $j=1$ where parent is the root with value $2 \times n - 1$.
        \item Sample up to two positions in the vector with value zero (childs).
        \item Set the value of childs in the vector as the index of the parent.
     \end{enumerate}
\end{enumerate}
In the end of the for loop we have a single numeric vector $v$ containing the structure of tree. Species or edge childs are given by the indexes of $v$ whereas the parent of a species stored at $i$ is obtained by simply accessing $v[i]$. Children of species $i$ are obtained by searching the vector for the element whose value is equal to $i$. If $v$ does not contain such value then $i$ is an extant species. The root is represented by value $2 \times n - 1$.
Although this was a neat and resource-wise cheap way to store and represent the tree, we are also required to store the length of each edge. Therefore we augmented this basic representation of the tree to a matrix that also includes the birth, termination and length of each species. Even though that for a given edge the value of the child is given by the index of the row, we added a column "Child" to the generated matrix in order to increase readibility (as we are not worried about the space tradeoff).

\bigskip
However, we did not label the nodes according to the example given, i.e. the parent node labelled as $n + 1$, the inner nodes between $n + 2$ and $2 x n - 1$ and the leaf nodes between $1$ and $n$. To that extent, we perform on \ref{sec:pt2} a simple reordering of the labels which does not affect the structure of the tree.
Finally we wrapped our method in a function that returns a data frame with further information, namely whether the species (or child) is extant or not.

<<size="small">>=
buildTree = function(n=10, lambda=0.5) {
  nspecies = (2*n - 2)
  cols = c("parent", "child", "birth", "termination", "length")
  
  tree = matrix(NA, nrow = nspecies, ncol = length(cols))
  colnames(tree) = cols
  tree[,c("parent", "child")] = 0
  
  t = 0
  for(k in 1:(n-1)) {
    if(k == 1) {
      parent = 2*n - 1
    } else {
      # A candidate edge is an edge of which the child is an extant
      # species. In this case we look for children which do not
      # have an entry in the vector of parents.
      candidates = which( ! (tree[, "child"] %in% tree[, "parent"]))
      # Length of candidates is always > 1 otherwise we would
      #  have to be careful with the behavior of sample
      #  (undesired behavior for length == 1)
      parent = sample(candidates, 1)
      t = t + rexp(1, rate = k*lambda) 
    }
    
    childs = sample(which(tree[,"parent"]==0), 2)
    tree[childs, "child"] = childs
    tree[childs, "parent"] = parent
    tree[childs, "birth"] = t
    if(k > 1) {
      tree[parent, "termination"] = t  
    }
  }
  t = t + rexp(1, rate = n*lambda)
  tree[is.na(tree[, "termination"]), "termination"] = t
  
  tree[, "length"] = tree[, "termination"] - tree[, "birth"]
  return(tree)
}

isExtant = function(tree, index=1:nrow(tree)) {
  ! (tree[index, "child"] %in% tree[, "parent"])
}

loadSpecies = function(path="../aux/species.txt") {
  species = read.table(path, header=FALSE, sep = "+", stringsAsFactors = FALSE)$V1
  species[-which(species=="unavailable")]
}

# Yet Another Yule (YAY)
yay = function(n=10, lambda=0.5) {
  tree = buildTree(n, lambda)
  species = loadSpecies()
  if(length(species) > 0) {
    nomes = species[sample(1:length(species), nrow(tree)+1)]  
  } else {
    nomes = paste("poney", 1:(nrow(tree)+1), sep="")
  }
  
  yule = data.frame(Parent      = tree[, "parent"],
                    ParentName  = nomes[tree[, "parent"]],
                    Child       = tree[, "child"], 
                    ChildName   = nomes[tree[, "child"]],
                    isExtant    = isExtant(tree),
                    Birth       = tree[, "birth"],
                    Termination = tree[, "termination"],
                    Length      = tree[, "length"])
  yule[yule$Parent == 2*n-1, ]$ParentName = nomes[2*n-1]
  return(yule)  
}

yule = yay()
head(yule, 1)
yule[, -c(2,4)]
@


\subsection*{Question (ii)}

Below is the function for computing the time-step changes in the number of extant lineages:

<<size="small">>=
yuleSteps = function(yule) {
  tstep = unique(sort(yule$Birth))
  tstep = c(tstep, max(yule$Termination))
  return(data.frame(tstep=tstep, nlineages=c(2:length(tstep), length(tstep))))
}

yuleSteps(yule)
@


\subsection*{Question (iii)}

Using the function previously defined we created a time series step-plot for
four different yule trees. It's worth noting that we coded this task so that
more plots could be generated using the same code (only required to change the
value of the variable \textit{nPlots}).

<<echo=FALSE, warning=F, message=F>>=
library(ggplot2)
library(plyr)
library(ape)
@


<<size="small">>=
n = 10
lambda=0.5
nPlots = 4

yays = lapply(1:nPlots, function(i) yuleSteps(yay(n, lambda)))
yays = rbind.fill(yays)
yays$group = ((as.numeric(rownames(yays)) - 1) %/% n) + 1

ggplot(yays, aes(x = tstep, y = nlineages))   +
  geom_step(aes(colour=factor(group))) +
  facet_wrap(~ group, ncol=nPlots %/% 2) + 
  ylab("Number of Lineages") +
  xlab("Time Steps") +
  theme_bw() +
  scale_colour_discrete(guide = FALSE)
@


%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
\section*{Part 2}\label{sec:pt2}

\subsection*{Question (i)}

At this stage, we introduced a new function to relabel the edges as required and return a phylo object instead.
The relabelling, aparently tricky at first, consisted in a simple re-order of parent and child labels based on whether the edge represented an extant or extinct species.

\bigskip
We created a new function instead of changing our previously defined $yay$ function, because each returns a different representation of the yule tree, even though the underlying structure is the same. Consider that we might be interested later in creating our own class for representing phylogentic trees, called $yay$. Then, separating concerns now across different functions without altering behavior would prove beneficial later.

<<size="small">>=
# Yet Another Phylo
yaPhylo = function(n=10, lambda=0.5) {
  yule = yay(n, lambda)
  
  # Relabelling the nodes
  yule[yule$isExtant==TRUE, ]$Child = 1:n
  yule[yule$isExtant==FALSE, ]$Child = (n+2):(2*n-1)
  yule$Parent = yule$Child[yule$Parent]
  yule[is.na(yule$Parent), ]$Parent = n + 1
  
  phylo = list(edge = matrix(c(yule$Parent, yule$Child), ncol = 2),
               edge.length = yule$Length,
               tip.label = paste("t", 1:n, sep=""),
               Nnode = n - 1)
  class(phylo) = "phylo"
  return(phylo)
}
@

\subsection*{Question (ii)}

The $length$ function for the phylo class consists in summing the lengths of all phylo edges:
<<size="small">>=
length.phylo = function(phylo) {
  sum(phylo$edge.length)
}
@

\subsection*{Question (iii)}

Using the plot method for the phylo class we created following four tree plots:
<<size="small">>=
n = 10
lambda =  0.5
par(mfrow=c(2,2))

for (i in 1:4) {
  phylo = yaPhylo(n, lambda)
  plot(phylo)
  title(main=paste("Tree", i),
        sub=paste("Phylogenetic Diversity:", round(length(phylo),2)),
        line = 1)
}
@

%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
\section*{Part 3: Investigating Properties of Trees}

\subsection*{R Functions}

\textbf{(i)}

The following function is used to calculate how many extant species are descendants of each of the two lineages which emerge from the root. 

<<>>=
degreeOfBalance = function(tree){
  num_of_leaves = length(tree$tip.label)
  # Returns the number of leaves within a particular tree
  root_node = num_of_leaves+1
  # Finds the number that the root node has been assigned to
  c1 = tree$edge[which(tree$edge==root_node)[1],2]
  c2 = tree$edge[which(tree$edge==root_node)[2],2]
  # Finds the two descendents of the root node

  if((c1<=num_of_leaves && c2<=num_of_leaves+1)  || 
     ((c2<=num_of_leaves && c1<=num_of_leaves+1))){
    # Check to see whether the descendents of the root are both leaf nodes 
    # ie. Tree with total of 2 leaf nodes 
    ret = c(1,1)
    return(ret)
  }else if(c1<=num_of_leaves || c2<=num_of_leaves){
    # Check to see whether a descendent of root is a leaf node
    desc1 = 1
    desc2 = num_of_leaves-1
    # For this condition to be true, 
    # all of the leaf nodes must descend from other root descendent
    ret = c(desc1, desc2)
    return(ret)
  }else{
    sub_tree1 = extract.clade(tree, c1)
    sub_tree2 = extract.clade(tree, c2)
    # Creates two trees where the root is either descendent of the root
    desc1 = length(sub_tree1$tip.label)
    desc2 = length(sub_tree2$tip.label)
    # Calculate number of leaves on each of the newly created trees
    ret = c(desc1,desc2)
    return(ret)
  }
}
@
\newpage
The following function counts the number of branches there are between each extant species and the root

<<>>=
numOfBranches = function(tree){
  num_of_leaves=length(tree$tip.label)
  # Calculates the total number of leaves on the tree
  root = num_of_leaves+1
  # Finds the number that the root node has been assigned to
  iterateBranch = function(tree, up){
    # Function which takes the tree and node number to count
    count = 0
    while(up!=root){
      # Continues to traverse towards the root via parent nodes until 
      # the root node has been reached
      up = tree$edge[which(tree$edge[,2]==up)]
      # Returns the parent node of the node we are currently on
      count = count + 1
      # Iterates counter to calculate number of parents nodes we have traveresed through
    }
    return(count)
  }
  store = sapply(1:num_of_leaves, function(i) iterateBranch(tree, i))
  # Calculates number of branches between each species and the root for each leaf
  names(store) = tree$tip.label[1:num_of_leaves]
  # Attributes vector names to the result of number of branches for each species 
  return(store)
}
@

The following code calculates the length of each pendant edge

<<>>=
lengthOfPendants = function(tree){
  num_of_leaves=length(tree$tip.label)
  # Calculates the number of leaves for the given tree
  penLength = rep(NA, num_of_leaves)
  penLength = tree$edge.length[1:num_of_leaves]
  # Extracts the lengths of the pendant edges
  return(penLength)
}
@

\textbf{(ii)}

The following code calculates three properties for a simulated yule tree. This is done using the functions defined in \textbf{part (ii)}

<<>>=
tree = yaPhylo(n = 16, lambda = 2.5)
# Generates a tree using the user defined function
balance = degreeOfBalance(tree)
# Calculates the number of extants species that are descendents of the two 
# lineages emerging from the root
sample(balance, 1)
# Samples the number of extant species from one of the descendents from the root
extants = numOfBranches(tree)
# Calculates number of branches between extant species and root
sample(extants, 1)
# Samples number of branches between itself and root for one of the extant species
penEdge = lengthOfPendants(tree)
# Calculates the length of the pendant for each extant species
sample(penEdge, 1)
# Samples one of the extant species and returns its length
@

The following function generates a tree, and calculates different properties on each of the trees. Including diversity, number of branches from extant species to root, length of pendant, and length of tree. 

<<>>=
calc_properties = function(dummy){
  tree = yaPhylo(n = 16, lambda = 2.5)
  # Generates a tree with 16 extant species and a lambda of 2.5
  d1 = sample(degreeOfBalance(tree),1) 
  d2 = sample(numOfBranches(tree),1) 
  d3 = sample(lengthOfPendants(tree),1)
  d4 = sample(length(tree),1) 
  # Sample each of the properties, as described above
  ret = c(d1,d2,d3,d4)
  # Returns the samples for each tree
  return(ret)
}
@



<<>>=
library("parallel") # Imports parallel library
cl = makeCluster(4) # Makes a cluster on all cores of the computer
clusterExport(cl, c("isExtant","loadSpecies","buildTree","yay","yaPhylo",
                    "calc_properties","degreeOfBalance","numOfBranches",
                    "lengthOfPendants","length.phylo","extract.clade"))
# Exports all of the objects which will be required when making the calculations
  n = parSapply(cl, 1:1000, calc_properties) 
  # Uses parSapply to run the function 1000 times, returning all values to n
stopCluster(cl) # Stops the cluster after use
@

The following code uses ggplot to plot the properties in histograms.  

<<size="small">>=
n=as.data.frame(t(n))
# Converts n to a dataframe to be used by ggplot
library(gridExtra) 
p1 = ggplot(n, aes(n[,1])) + geom_histogram(bins = 30) + ggtitle("Diversity") + 
  labs(x="Value", y="Count")
# Use of ggplot to plot histograms, with 30 bins
p2 = ggplot(n, aes(n[,2])) + geom_histogram(bins = 20) + ggtitle("Number of Branches")+
  labs(x="Value", y="Count")
p3 = ggplot(n, aes(n[,3])) + geom_histogram(bins = 30) + ggtitle("Length of Pendant") +
  labs(x="Value", y="Count")
p4 = ggplot(n, aes(n[,4])) + geom_histogram(bins = 30) + ggtitle("Length") + 
  labs(x="Value", y="Count")
grid.arrange(p1,p2,p3,p4) # Use of gridExtra package to arrange plots in 2 columns and 2 rows
@

The plots show varying distributions for each of the tree properties. The diversity of the tree seems to be uniform. With values falling between 1 and 15. 

The number of branches between an extant and the root seems to follow a normal distribution, with the mode being 4 branches. There seem to be very little counts where there is just 1 branch between the extant and root, and also where there are over 8 branches. This distribution can be explained by the number of extant species set at the generation of the tree. The algorithm stops at 16 species, and therefore does not leave time for successive branches to be made. 

The length of the pedant seems to follow an exponential distribution. This is due to the fact that these timings are generated from an exponential distribution when the tree is generated. This is the same for the length of the tree.







%--------------------------------------------------------------------%
%--------------------------------------------------------------------%
%--------------------------------------------------------------------%

\end{document}